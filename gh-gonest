#!/usr/bin/env bash
###############################################################################
# gh-gonest: GitHub Ghost Notification Cleaner
# Removes phantom notifications from deleted/banned repositories
###############################################################################

set -euo pipefail

###############################################################################
# Global Configuration
###############################################################################

# Version information
readonly VERSION="0.1.0"

# Debug support
DEBUG="${GONEST_DEBUG:-}"

# Colors for elegant output (only if terminal supports colors)
if [[ -t 1 ]] && command -v tput >/dev/null 2>&1 && tput colors >/dev/null 2>&1 && [[ $(tput colors) -ge 8 ]]; then
    RED='\033[0;31m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    GRAY='\033[0;90m'
    NC='\033[0m'
else
    RED=''
    YELLOW=''
    BLUE=''
    GRAY=''
    NC=''
fi

# Global variables
AFTER_DATE=""
BEFORE_DATE=""
DRY_RUN=false
NOTIFICATIONS_JSON=""
PHANTOM_NOTIFICATIONS=()

###############################################################################
# Helper Functions
###############################################################################

# Debug function
debug() {
    if [[ -n "$DEBUG" ]]; then
        echo -e "${GRAY}[DBUG]${NC} $*" >&2
    fi
}

# Logging functions
info() { echo -e "${BLUE}[INFO]${NC} $*"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
fail() { echo -e "${RED}[FAIL]${NC} $*" >&2; }

# Error function that logs and exits
die() {
    fail "$*"
    exit 1
}

# Version information
show_version() {
    echo "gh-gonest $VERSION"
}

# Usage information
usage() {
    cat << EOF
gh-gonest - GitHub Ghost Notification Cleaner

USAGE:
    gh gonest [OPTIONS]

OPTIONS:
    --after TIMESTAMP        Only check notifications after this time (ISO 8601 UTC: YYYY-MM-DDTHH:MM:SSZ)
    --before TIMESTAMP       Only check notifications before this time (ISO 8601 UTC: YYYY-MM-DDTHH:MM:SSZ)
    --dry-run                Show what would be cleaned without making changes
    --help, -h               Show this help message
    --version, -v            Show version information

DESCRIPTION:
    Scans for phantom notifications from deleted/banned repositories
    and removes them to clean up your notification bell.

EXAMPLES:
    gh gonest                                                             # Scan and clean
    gh gonest --dry-run                                                   # Scan and preview what would be cleaned
    gh gonest --after 2025-09-01T00:00:00Z                                # Only check notifications after Sept 1st
    gh gonest --before 2025-09-30T23:59:59Z                               # Only check notifications before Sept 30th
    gh gonest --after 2025-09-01T00:00:00Z --before 2025-09-30T23:59:59Z  # Check September only

EOF
}

# Validate ISO 8601 UTC timestamp format
validate_timestamp() {
    local timestamp="$1"
    # Check format: YYYY-MM-DDTHH:MM:SSZ
    if [[ $timestamp =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z$ ]]; then
        return 0
    else
        return 1
    fi
}

# Validate parsed arguments
validate_arguments() {
    debug "Validating parsed arguments"

    # Validate --after timestamp
    if [[ -n "$AFTER_DATE" ]]; then
        if ! validate_timestamp "$AFTER_DATE"; then
            die "Invalid --after timestamp format"
        fi
        debug "After date validation passed: $AFTER_DATE"
    fi

    # Validate --before timestamp
    if [[ -n "$BEFORE_DATE" ]]; then
        if ! validate_timestamp "$BEFORE_DATE"; then
            die "Invalid --before timestamp format"
        fi
        debug "Before date validation passed: $BEFORE_DATE"
    fi
}

# Parse command line arguments
parse_args() {
    debug "Parsing command line arguments: $*"
    while [[ $# -gt 0 ]]; do
        case $1 in
            --after)
                if [[ $# -lt 2 || -z "${2:-}" ]]; then
                    die "Option --after requires a timestamp"
                fi
                AFTER_DATE="$2"
                debug "Set after date filter: $AFTER_DATE"
                shift 2
                ;;
            --before)
                if [[ $# -lt 2 || -z "${2:-}" ]]; then
                    die "Option --before requires a timestamp"
                fi
                BEFORE_DATE="$2"
                debug "Set before date filter: $BEFORE_DATE"
                shift 2
                ;;
            --dry-run)
                debug "Enabling dry-run mode"
                DRY_RUN=true
                shift
                ;;
            --help|-h)
                usage
                exit 0
                ;;
            --version|-v)
                show_version
                exit 0
                ;;
            *)
                fail "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done
}

# Check prerequisites
check_prerequisites() {
    debug "Checking prerequisites..."

    # Check if gh is installed
    if ! command -v gh >/dev/null 2>&1; then
        die "GitHub CLI (gh) is not installed"
    fi

    # Check if jq is installed
    if ! command -v jq >/dev/null 2>&1; then
        die "jq is required but not installed"
    fi

    # Check if authenticated with GitHub
    if ! gh auth status >/dev/null 2>&1; then
        die "Not authenticated with GitHub. Run: gh auth login"
    fi

    debug "All prerequisites met"
}

# Fetch all notifications
fetch_notifications() {
    info "Scanning for notifications..."

    local api_params=""

    # Add since parameter if --after is specified
    if [[ -n "$AFTER_DATE" ]]; then
        api_params="since=$AFTER_DATE"
        info "Filtering notifications after: $AFTER_DATE"
    fi

    # Fetch notifications from GitHub API directly into memory
    local notifications_json
    if [[ -n "$api_params" ]]; then
        debug "Fetching notifications with parameters: $api_params"
        if ! notifications_json=$(gh api "notifications?$api_params" --paginate 2>/dev/null); then
            die "Failed to fetch notifications with parameters from GitHub API"
        fi
    else
        debug "Fetching all notifications"
        if ! notifications_json=$(gh api notifications --paginate 2>/dev/null); then
            die "Failed to fetch notifications from GitHub API"
        fi
    fi

    # Client-side filtering for --before (GitHub API doesn't support "until" parameter)
    if [[ -n "$BEFORE_DATE" ]]; then
        info "Filtering notifications before: $BEFORE_DATE"
        if ! notifications_json=$(echo "$notifications_json" | jq --arg before "$BEFORE_DATE" '[.[] | select(.updated_at < $before)]' 2>/dev/null); then
            die "Failed to filter notifications by date"
        fi
    fi

    # Check if we have any notifications
    local count
    if ! count=$(echo "$notifications_json" | jq length 2>/dev/null); then
        die "Failed to count notifications in response"
    fi
    if [[ "$count" -eq 0 ]]; then
        info "No notifications found in the specified time range"
        exit 0
    fi

    info "Found $count total notifications"

    # Store in global variable for other functions to use
    NOTIFICATIONS_JSON="$notifications_json"
}

# Check if a repository exists (returns 0 if exists, 1 if phantom)
check_repository() {
    local repo_full_name="$1"
    debug "Checking repository: $repo_full_name"
    gh api "repos/$repo_full_name" >/dev/null 2>&1
    local exit_code=$?
    if [[ $exit_code -eq 0 ]]; then
        debug "Repository exists: $repo_full_name"
        return 0
    else
        debug "Repository not found (phantom): $repo_full_name"
        return 1
    fi
}

# Scan for phantom notifications
scan_phantoms() {
    info "Checking for phantom notifications..."

    local phantom_count=0
    local total_notifications
    total_notifications=$(echo "$NOTIFICATIONS_JSON" | jq length)
    local current=0

    debug "Starting scan of $total_notifications notifications"

    for i in $(seq 0 $((total_notifications - 1))); do
        current=$((current + 1))

        # Get notification by index
        local notification
        if ! notification=$(echo "$NOTIFICATIONS_JSON" | jq -c ".[$i]" 2>/dev/null); then
            die "Failed to extract notification details from response"
        fi

        local repo_name
        local subject_title
        local subject_type
        repo_name=$(echo "$notification" | jq -r '.repository.full_name')
        subject_title=$(echo "$notification" | jq -r '.subject.title')
        subject_type=$(echo "$notification" | jq -r '.subject.type')

        debug "Processing notification: $repo_name ($subject_type)"

        # Check if repository exists
        if ! check_repository "$repo_name"; then
            PHANTOM_NOTIFICATIONS+=("$notification")
            phantom_count=$((phantom_count + 1))
            warn "Found phantom: $repo_name - $subject_type: $subject_title"
        fi
    done

    if [[ $phantom_count -eq 0 ]]; then
        debug "Scan completed: no phantoms found"
        info "No phantom notifications found - all clean!"
        return 0
    fi

    debug "Scan completed: found $phantom_count phantom notification(s)"
    info "Found $phantom_count phantom notification(s)"
}

# Clean a single phantom notification
clean_notification() {
    local notification="$1"
    local thread_url
    local subscription_url
    local repo_name
    thread_url=$(echo "$notification" | jq -r '.url')
    subscription_url=$(echo "$notification" | jq -r '.subscription_url')
    repo_name=$(echo "$notification" | jq -r '.repository.full_name')

    debug "Cleaning notification for $repo_name"

    # Step 1: Mark as read
    if ! gh api --method PATCH "$thread_url" >/dev/null 2>&1; then
        warn "Failed to mark as read: $repo_name. Skipping..." >&2
        return 1
    fi

    # Step 2: Mark as done
    if ! gh api --method DELETE "$thread_url" >/dev/null 2>&1; then
        warn "Failed to mark as done: $repo_name. Skipping..." >&2
        return 1
    fi

    # Step 3: Unsubscribe
    if [[ "$subscription_url" != "null" && -n "$subscription_url" && "$subscription_url" =~ ^https?:// ]]; then
        debug "Unsubscribing from: $subscription_url"
        if ! gh api --method DELETE "$subscription_url" >/dev/null 2>&1; then
            warn "Failed to unsubscribe from: $repo_name. Skipping..."
            return 1
        fi
    else
        warn "No valid subscription URL to unsubscribe from"
        return 1
    fi

    return 0
}

# Clean all phantom notifications
clean_phantoms() {
    # If no phantoms found, nothing to clean
    if [[ ${#PHANTOM_NOTIFICATIONS[@]} -eq 0 ]]; then
        return 0
    fi

    if [[ $DRY_RUN == true ]]; then
        info "Would clean ${#PHANTOM_NOTIFICATIONS[@]} phantom notification(s) - run without --dry-run for cleanup"
        return 0
    fi

    info "Cleaning phantom notifications..."

    local cleaned=0
    local failed=0

    for notification in "${PHANTOM_NOTIFICATIONS[@]}"; do
        local repo_name
        repo_name=$(echo "$notification" | jq -r '.repository.full_name')

        if clean_notification "$notification"; then
            info "Cleaned: $repo_name"
            cleaned=$((cleaned + 1))
        else
            failed=$((failed + 1))
        fi
    done

    info "Cleanup complete!"
    if [[ $failed -gt 0 ]]; then
        warn "Summary: Cleaned $cleaned, failed $failed"
        return 1
    fi
    info "Summary: Successfully cleaned $cleaned"
    return 0
}

###############################################################################
# Main Execution Flow
###############################################################################

main() {
    debug "Starting gh-gonest v$VERSION"
    parse_args "$@"
    validate_arguments
    check_prerequisites

    info "gh-gonest - GitHub Ghost Notification Cleaner"

    fetch_notifications
    scan_phantoms

    if clean_phantoms; then
        info "Execution completed successfully"
        exit 0
    else
        warn "Execution completed with cleanup failures"
        exit 1
    fi
}

###############################################################################
# Script Execution
###############################################################################

main "$@"
